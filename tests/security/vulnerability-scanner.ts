/**
 * Vulnerability Scanner Module
 * Automated OWASP Top 10 vulnerability detection and security scanning
 *
 * Phase 2: API Security Testing - Vulnerability Detection
 * - OWASP Top 10 automated scanning
 * - Security headers validation
 * - Cryptographic security testing
 * - Automated penetration testing patterns
 */

import { z } from 'zod'
import {
  AttackSimulator,
  type SecurityScanResult,
  type SecurityTestResult,
} from './core-security-utilities'

// OWASP Top 10 vulnerability categories
export const OWASP_TOP_10 = [
  'A01:2021-BROKEN_ACCESS_CONTROL',
  'A02:2021-CRYPTOGRAPHIC_FAILURES',
  'A03:2021-INJECTION',
  'A04:2021-INSECURE_DESIGN',
  'A05:2021-SECURITY_MISCONFIGURATION',
  'A06:2021-VULNERABLE_COMPONENTS',
  'A07:2021-IDENTIFICATION_AUTHENTICATION_FAILURES',
  'A08:2021-SOFTWARE_DATA_INTEGRITY_FAILURES',
  'A09:2021-SECURITY_LOGGING_MONITORING_FAILURES',
  'A10:2021-SERVER_SIDE_REQUEST_FORGERY',
] as const

export type OWASPCategory = (typeof OWASP_TOP_10)[number]

// Vulnerability scan configuration
export const VulnerabilityScanConfigSchema = z.object({
  targets: z.array(
    z.object({
      url: z.string().url(),
      endpoints: z.array(z.string()),
      priority: z.enum(['LOW', 'MEDIUM', 'HIGH', 'CRITICAL']).default('MEDIUM'),
    })
  ),
  scanTypes: z
    .array(
      z.enum([
        'SQL_INJECTION',
        'XSS',
        'CSRF',
        'AUTHENTICATION_BYPASS',
        'AUTHORIZATION_FLAWS',
        'SECURITY_HEADERS',
        'CRYPTOGRAPHIC_WEAKNESSES',
        'INPUT_VALIDATION',
        'SESSION_MANAGEMENT',
        'INFORMATION_DISCLOSURE',
      ])
    )
    .default([
      'SQL_INJECTION',
      'XSS',
      'AUTHENTICATION_BYPASS',
      'SECURITY_HEADERS',
      'INPUT_VALIDATION',
    ]),
  aggressive: z.boolean().default(false),
  maxConcurrency: z.number().min(1).max(10).default(3),
  timeout: z.number().min(1000).max(30000).default(10000),
})

export type VulnerabilityScanConfig = z.infer<typeof VulnerabilityScanConfigSchema>

// Security headers configuration
export const SECURITY_HEADERS_CONFIG = {
  'Content-Security-Policy': {
    required: true,
    patterns: [/default-src\s+[^;]+/, /script-src\s+[^;]+/, /style-src\s+[^;]+/],
    severity: 'HIGH' as const,
  },
  'X-Content-Type-Options': {
    required: true,
    expectedValue: 'nosniff',
    severity: 'MEDIUM' as const,
  },
  'X-Frame-Options': {
    required: true,
    expectedValues: ['DENY', 'SAMEORIGIN'],
    severity: 'HIGH' as const,
  },
  'X-XSS-Protection': {
    required: true,
    expectedValue: '1; mode=block',
    severity: 'MEDIUM' as const,
  },
  'Strict-Transport-Security': {
    required: true,
    patterns: [/max-age=\d+/],
    severity: 'HIGH' as const,
  },
  'Referrer-Policy': {
    required: true,
    expectedValues: ['strict-origin-when-cross-origin', 'strict-origin', 'no-referrer'],
    severity: 'MEDIUM' as const,
  },
  'Permissions-Policy': {
    required: false,
    patterns: [/camera=\(\), microphone=\(\)/],
    severity: 'LOW' as const,
  },
} as const

/**
 * Comprehensive Vulnerability Scanner
 */
export class VulnerabilityScanner {
  private attackSimulator: AttackSimulator
  private results: SecurityTestResult[] = []

  constructor() {
    this.attackSimulator = new AttackSimulator()
  }

  /**
   * Perform comprehensive OWASP Top 10 vulnerability scan
   */
  async performOWASPScan(config: VulnerabilityScanConfig): Promise<SecurityScanResult> {
    const startTime = performance.now()
    const validatedConfig = VulnerabilityScanConfigSchema.parse(config)

    this.results = []

    // Run scans for each target
    for (const target of validatedConfig.targets) {
      await this.scanTarget(target, validatedConfig)
    }

    const duration = performance.now() - startTime

    return this.generateScanReport(duration)
  }

  /**
   * Scan individual target for vulnerabilities
   */
  private async scanTarget(
    target: VulnerabilityScanConfig['targets'][0],
    config: VulnerabilityScanConfig
  ): Promise<void> {
    const scanPromises: Promise<SecurityTestResult>[] = []

    for (const endpoint of target.endpoints) {
      const fullUrl = `${target.url}${endpoint}`

      // SQL Injection scanning
      if (config.scanTypes.includes('SQL_INJECTION')) {
        scanPromises.push(this.attackSimulator.testSQLInjection(fullUrl, 'q'))
        if (config.aggressive) {
          scanPromises.push(this.scanAdvancedSQLInjection(fullUrl))
        }
      }

      // XSS scanning
      if (config.scanTypes.includes('XSS')) {
        scanPromises.push(this.attackSimulator.testXSS(fullUrl, 'q'))
        if (config.aggressive) {
          scanPromises.push(this.scanAdvancedXSS(fullUrl))
        }
      }

      // Authentication bypass
      if (config.scanTypes.includes('AUTHENTICATION_BYPASS')) {
        scanPromises.push(this.attackSimulator.testAuthenticationBypass(fullUrl))
      }

      // Security headers validation
      if (config.scanTypes.includes('SECURITY_HEADERS')) {
        scanPromises.push(this.scanSecurityHeaders(fullUrl))
      }

      // Input validation testing
      if (config.scanTypes.includes('INPUT_VALIDATION')) {
        scanPromises.push(this.scanInputValidation(fullUrl))
      }

      // CSRF testing
      if (config.scanTypes.includes('CSRF')) {
        scanPromises.push(this.scanCSRFProtection(fullUrl))
      }

      // Authorization flaws
      if (config.scanTypes.includes('AUTHORIZATION_FLAWS')) {
        scanPromises.push(this.scanAuthorizationFlaws(fullUrl))
      }

      // Cryptographic weaknesses
      if (config.scanTypes.includes('CRYPTOGRAPHIC_WEAKNESSES')) {
        scanPromises.push(this.scanCryptographicWeaknesses(fullUrl))
      }

      // Information disclosure
      if (config.scanTypes.includes('INFORMATION_DISCLOSURE')) {
        scanPromises.push(this.scanInformationDisclosure(fullUrl))
      }
    }

    // Execute scans with concurrency control
    const chunks = this.chunkArray(scanPromises, config.maxConcurrency)
    for (const chunk of chunks) {
      const results = await Promise.allSettled(chunk)

      for (const result of results) {
        if (result.status === 'fulfilled') {
          this.results.push(result.value)
        } else {
          console.error('Scan failed:', result.reason)
        }
      }
    }
  }

  /**
   * Advanced SQL injection testing with time-based and union-based attacks
   */
  private async scanAdvancedSQLInjection(endpoint: string): Promise<SecurityTestResult> {
    const startTime = performance.now()
    const vulnerabilities: string[] = []

    // Time-based blind SQL injection payloads
    const timeBasedPayloads = [
      "'; SELECT CASE WHEN (1=1) THEN pg_sleep(3) ELSE pg_sleep(0) END; --",
      "' AND (SELECT COUNT(*) FROM information_schema.tables) > 0 AND pg_sleep(3) --",
      "'; WAITFOR DELAY '00:00:03'; --", // SQL Server
      "' OR (SELECT SLEEP(3)) --", // MySQL
    ]

    for (const payload of timeBasedPayloads) {
      try {
        const testStart = performance.now()
        const url = new URL(endpoint)
        url.searchParams.set('q', payload)

        const _response = await fetch(url.toString(), {
          signal: AbortSignal.timeout(5000),
        })

        const testDuration = performance.now() - testStart

        // If response takes significantly longer, might indicate successful injection
        if (testDuration > 2500) {
          vulnerabilities.push(
            `Time-based SQL injection detected: ${payload} (${testDuration.toFixed(0)}ms)`
          )
        }
      } catch (error) {
        // Timeout might indicate successful sleep injection
        if (error instanceof DOMException && error.name === 'TimeoutError') {
          vulnerabilities.push(`Time-based SQL injection timeout: ${payload}`)
        }
      }
    }

    const executionTime = performance.now() - startTime

    return {
      testName: 'Advanced SQL Injection Test',
      category: 'INJECTION',
      status: vulnerabilities.length > 0 ? 'FAIL' : 'PASS',
      severity: vulnerabilities.length > 0 ? 'CRITICAL' : 'LOW',
      details:
        vulnerabilities.length > 0
          ? `Found ${vulnerabilities.length} advanced SQL injection vulnerabilities`
          : 'No advanced SQL injection vulnerabilities detected',
      evidence: vulnerabilities,
      recommendations:
        vulnerabilities.length > 0
          ? [
              'Implement parameterized queries for ALL database operations',
              'Add query timeout limits to prevent time-based attacks',
              'Implement database activity monitoring and alerting',
              'Use least-privilege database accounts',
              'Enable SQL query logging for security analysis',
            ]
          : [],
      executionTime,
      timestamp: new Date(),
    }
  }

  /**
   * Advanced XSS testing including DOM-based and stored XSS patterns
   */
  private async scanAdvancedXSS(endpoint: string): Promise<SecurityTestResult> {
    const startTime = performance.now()
    const vulnerabilities: string[] = []

    // DOM-based XSS payloads
    const domXSSPayloads = [
      '#<script>alert("DOM-XSS")</script>',
      '#javascript:alert(document.domain)',
      '#"><img src=x onerror=alert(1)>',
      'javascript:alert(String.fromCharCode(88,83,83))',
    ]

    // Filter bypass payloads
    const bypassPayloads = [
      '<img src="x" onerror="&#97;&#108;&#101;&#114;&#116;&#40;&#49;&#41;">',
      '<svg><script>alert&#40;1&#41;</script>',
      '<iframe src="data:text/html,<script>alert(1)</script>">',
      '"><svg/onload=alert(/XSS/)>',
      "'-confirm(1)-'",
      '"><script src="//xss.rocks/xss.js"></script>',
    ]

    const allPayloads = [...domXSSPayloads, ...bypassPayloads]

    for (const payload of allPayloads) {
      try {
        const url = new URL(endpoint)
        url.searchParams.set('q', payload)

        const response = await fetch(url.toString())
        const responseText = await response.text()

        // Check for unencoded payload reflection
        if (responseText.includes(payload.replace(/[<>"']/g, ''))) {
          vulnerabilities.push(`Advanced XSS payload bypassed filtering: ${payload}`)
        }

        // Check for partial payload success
        const dangerousStrings = ['<script', 'javascript:', 'onerror=', 'onload=']
        for (const dangerous of dangerousStrings) {
          if (responseText.toLowerCase().includes(dangerous.toLowerCase())) {
            vulnerabilities.push(`XSS filter bypass detected with: ${payload}`)
            break
          }
        }
      } catch (_error) {
        // Continue with next payload
      }
    }

    const executionTime = performance.now() - startTime

    return {
      testName: 'Advanced XSS Test',
      category: 'XSS',
      status: vulnerabilities.length > 0 ? 'FAIL' : 'PASS',
      severity: vulnerabilities.length > 0 ? 'HIGH' : 'LOW',
      details:
        vulnerabilities.length > 0
          ? `Found ${vulnerabilities.length} advanced XSS vulnerabilities`
          : 'No advanced XSS vulnerabilities detected',
      evidence: vulnerabilities,
      recommendations:
        vulnerabilities.length > 0
          ? [
              'Implement context-aware output encoding',
              'Use Content Security Policy (CSP) with strict directives',
              'Sanitize input on both client and server side',
              'Implement DOM-based XSS protection',
              'Use trusted types API where supported',
              'Validate all input against allowlists, not blocklists',
            ]
          : [],
      executionTime,
      timestamp: new Date(),
    }
  }

  /**
   * Security headers validation
   */
  private async scanSecurityHeaders(endpoint: string): Promise<SecurityTestResult> {
    const startTime = performance.now()
    const missingHeaders: string[] = []
    const weakHeaders: string[] = []

    try {
      const response = await fetch(endpoint)

      for (const [headerName, config] of Object.entries(SECURITY_HEADERS_CONFIG)) {
        const headerValue = response.headers.get(headerName)

        if (!headerValue) {
          if (config.required) {
            missingHeaders.push(`Missing required header: ${headerName}`)
          }
          continue
        }

        // Check expected values
        if ('expectedValue' in config && headerValue !== config.expectedValue) {
          weakHeaders.push(
            `Weak ${headerName}: Expected "${config.expectedValue}", got "${headerValue}"`
          )
        }

        if ('expectedValues' in config && !config.expectedValues.includes(headerValue)) {
          weakHeaders.push(
            `Weak ${headerName}: Expected one of ${config.expectedValues.join(', ')}, got "${headerValue}"`
          )
        }

        // Check patterns
        if ('patterns' in config) {
          const matchesPattern = config.patterns.some(pattern => pattern.test(headerValue))
          if (!matchesPattern) {
            weakHeaders.push(`Weak ${headerName}: Does not match security patterns`)
          }
        }
      }
    } catch (error) {
      return {
        testName: 'Security Headers Test',
        category: 'CSRF',
        status: 'ERROR',
        severity: 'MEDIUM',
        details: `Failed to fetch headers: ${error}`,
        evidence: [],
        recommendations: ['Ensure endpoint is accessible for security testing'],
        executionTime: performance.now() - startTime,
        timestamp: new Date(),
      }
    }

    const executionTime = performance.now() - startTime
    const issues = [...missingHeaders, ...weakHeaders]

    return {
      testName: 'Security Headers Test',
      category: 'CSRF',
      status: issues.length > 0 ? 'FAIL' : 'PASS',
      severity: missingHeaders.length > 0 ? 'HIGH' : weakHeaders.length > 0 ? 'MEDIUM' : 'LOW',
      details:
        issues.length > 0
          ? `Found ${issues.length} security header issues`
          : 'All security headers properly configured',
      evidence: issues,
      recommendations:
        issues.length > 0
          ? [
              'Implement all required security headers',
              'Use strict Content Security Policy directives',
              'Enable HSTS with appropriate max-age',
              'Configure X-Frame-Options to prevent clickjacking',
              'Set X-Content-Type-Options to prevent MIME sniffing',
            ]
          : [],
      executionTime,
      timestamp: new Date(),
    }
  }

  /**
   * Input validation testing with fuzzing
   */
  private async scanInputValidation(endpoint: string): Promise<SecurityTestResult> {
    const startTime = performance.now()
    const vulnerabilities: string[] = []

    // Fuzzing payloads for input validation
    const fuzzingPayloads = [
      // Buffer overflow attempts
      'A'.repeat(10000),
      'A'.repeat(100000),

      // Format string attacks
      '%n%n%n%n%n',
      '%s%s%s%s%s',
      '%x%x%x%x%x',

      // Null bytes and control characters
      '\x00\x01\x02\x03',
      '\n\r\t\b\f',

      // Unicode attacks
      '\u0000\u0001\u0002',
      '\ufeff\u200b\u200c',

      // Encoding attacks
      '%2e%2e%2f',
      '..%2f',
      '%00',

      // Nested encoding
      '%252e%252e%252f',
      '%25%32%65',
    ]

    for (const payload of fuzzingPayloads) {
      try {
        const url = new URL(endpoint)
        url.searchParams.set('q', payload)

        const response = await fetch(url.toString())

        // Check for server errors that might indicate vulnerability
        if (response.status === 500) {
          const errorText = await response.text()
          if (errorText.includes('error') || errorText.includes('exception')) {
            vulnerabilities.push(
              `Server error with fuzzing payload: ${payload.substring(0, 50)}...`
            )
          }
        }

        // Check for payload reflection without sanitization
        const responseText = await response.text()
        if (payload.length > 1000 && responseText.includes(payload.substring(0, 100))) {
          vulnerabilities.push(
            `Large payload reflected unsanitized: ${payload.substring(0, 50)}...`
          )
        }
      } catch (error) {
        if (error instanceof TypeError && error.message.includes('network')) {
          vulnerabilities.push(`Network disruption with payload: ${payload.substring(0, 50)}...`)
        }
      }
    }

    const executionTime = performance.now() - startTime

    return {
      testName: 'Input Validation Fuzzing Test',
      category: 'INPUT_VALIDATION',
      status: vulnerabilities.length > 0 ? 'FAIL' : 'PASS',
      severity: vulnerabilities.length > 0 ? 'MEDIUM' : 'LOW',
      details:
        vulnerabilities.length > 0
          ? `Found ${vulnerabilities.length} input validation issues`
          : 'Input validation appears robust',
      evidence: vulnerabilities,
      recommendations:
        vulnerabilities.length > 0
          ? [
              'Implement strict input validation on all parameters',
              'Use allowlists instead of blocklists for validation',
              'Limit input length and character sets',
              'Sanitize all user input before processing',
              'Implement proper error handling to avoid information disclosure',
            ]
          : [],
      executionTime,
      timestamp: new Date(),
    }
  }

  /**
   * CSRF protection testing
   */
  private async scanCSRFProtection(endpoint: string): Promise<SecurityTestResult> {
    const startTime = performance.now()
    const vulnerabilities: string[] = []

    try {
      // Test for CSRF token requirement
      const postResponse = await fetch(endpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ test: 'csrf_test' }),
      })

      // If POST succeeds without CSRF token, it's vulnerable
      if (postResponse.status === 200) {
        vulnerabilities.push('POST request succeeded without CSRF token')
      }

      // Check for CSRF token in response headers/cookies
      const csrfHeaders = ['X-CSRF-Token', 'X-XSRF-Token', 'CSRF-Token', 'Authenticity-Token']

      const hasCSRFHeader = csrfHeaders.some(header => postResponse.headers.has(header))

      if (!hasCSRFHeader) {
        vulnerabilities.push('No CSRF token headers detected')
      }

      // Test with fake referrer (CSRF attack simulation)
      const fakeReferrerResponse = await fetch(endpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Referer: 'https://malicious-site.com',
          Origin: 'https://malicious-site.com',
        },
        body: JSON.stringify({ test: 'csrf_attack' }),
      })

      if (fakeReferrerResponse.status === 200) {
        vulnerabilities.push('Request succeeded with malicious origin/referer')
      }
    } catch (_error) {
      // Network errors might be expected for CSRF protection
    }

    const executionTime = performance.now() - startTime

    return {
      testName: 'CSRF Protection Test',
      category: 'CSRF',
      status: vulnerabilities.length > 0 ? 'FAIL' : 'PASS',
      severity: vulnerabilities.length > 0 ? 'HIGH' : 'LOW',
      details:
        vulnerabilities.length > 0
          ? `Found ${vulnerabilities.length} CSRF protection issues`
          : 'CSRF protection appears adequate',
      evidence: vulnerabilities,
      recommendations:
        vulnerabilities.length > 0
          ? [
              'Implement CSRF tokens for all state-changing operations',
              'Validate Origin and Referer headers',
              'Use SameSite cookie attributes',
              'Implement double-submit cookie pattern',
              'Use framework-provided CSRF protection',
            ]
          : [],
      executionTime,
      timestamp: new Date(),
    }
  }

  /**
   * Authorization flaws testing
   */
  private async scanAuthorizationFlaws(endpoint: string): Promise<SecurityTestResult> {
    const startTime = performance.now()
    const vulnerabilities: string[] = []

    // Test different authorization scenarios
    const authTests = [
      { name: 'No Authorization', headers: {} },
      { name: 'Invalid Token', headers: { Authorization: 'Bearer invalid-token-12345' } },
      {
        name: 'Expired Token',
        headers: {
          Authorization:
            'Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE2MDk0NTkyMDB9.expired',
        },
      },
      { name: 'Malformed Token', headers: { Authorization: 'Bearer not-a-jwt-token' } },
      {
        name: 'SQL Injection in Auth',
        headers: { Authorization: "Bearer '; DROP TABLE users; --" },
      },
    ]

    for (const test of authTests) {
      try {
        const response = await fetch(endpoint, {
          headers: test.headers,
        })

        // Check if unauthorized requests return proper status codes
        if (response.status === 200 && test.name !== 'Valid Token') {
          vulnerabilities.push(`${test.name}: Request succeeded when it should have failed`)
        }

        // Check for information disclosure in error responses
        if (response.status >= 400) {
          const responseText = await response.text()

          // Look for sensitive information in error messages
          const sensitivePatterns = [
            /database.*error/i,
            /sql.*syntax/i,
            /stack.*trace/i,
            /internal.*error/i,
            /debug.*info/i,
          ]

          for (const pattern of sensitivePatterns) {
            if (pattern.test(responseText)) {
              vulnerabilities.push(`${test.name}: Information disclosure in error response`)
              break
            }
          }
        }
      } catch (error) {
        // Network errors might indicate successful attack
        if (error instanceof Error && error.message.includes('network')) {
          vulnerabilities.push(`${test.name}: Network disruption (potential DoS)`)
        }
      }
    }

    const executionTime = performance.now() - startTime

    return {
      testName: 'Authorization Flaws Test',
      category: 'AUTHORIZATION',
      status: vulnerabilities.length > 0 ? 'FAIL' : 'PASS',
      severity: vulnerabilities.length > 0 ? 'HIGH' : 'LOW',
      details:
        vulnerabilities.length > 0
          ? `Found ${vulnerabilities.length} authorization issues`
          : 'Authorization mechanisms appear secure',
      evidence: vulnerabilities,
      recommendations:
        vulnerabilities.length > 0
          ? [
              'Implement proper authentication and authorization checks',
              'Return consistent error messages to prevent information disclosure',
              'Use principle of least privilege for user permissions',
              'Implement proper JWT validation and expiration handling',
              'Log and monitor authorization failures',
            ]
          : [],
      executionTime,
      timestamp: new Date(),
    }
  }

  /**
   * Cryptographic weaknesses testing
   */
  private async scanCryptographicWeaknesses(endpoint: string): Promise<SecurityTestResult> {
    const startTime = performance.now()
    const vulnerabilities: string[] = []

    try {
      const response = await fetch(endpoint)

      // Check TLS/HTTPS configuration
      const url = new URL(endpoint)
      if (url.protocol !== 'https:') {
        vulnerabilities.push('Endpoint not using HTTPS encryption')
      }

      // Check for weak session cookies
      const cookies = response.headers.get('Set-Cookie')
      if (cookies) {
        if (!cookies.includes('Secure')) {
          vulnerabilities.push('Session cookies missing Secure flag')
        }
        if (!cookies.includes('HttpOnly')) {
          vulnerabilities.push('Session cookies missing HttpOnly flag')
        }
        if (!cookies.includes('SameSite')) {
          vulnerabilities.push('Session cookies missing SameSite attribute')
        }
      }

      // Check for weak random tokens in response
      const responseText = await response.text()
      const tokenPatterns = [
        /token["']\s*:\s*["']([a-zA-Z0-9]{8,})["']/g,
        /csrf["']\s*:\s*["']([a-zA-Z0-9]{8,})["']/g,
        /session["']\s*:\s*["']([a-zA-Z0-9]{8,})["']/g,
      ]

      for (const pattern of tokenPatterns) {
        const matches = responseText.match(pattern)
        if (matches) {
          for (const match of matches) {
            const token = match.split(':')[1]?.replace(/["']/g, '').trim()
            if (token && this.isWeakToken(token)) {
              vulnerabilities.push(
                `Weak cryptographic token detected: ${token.substring(0, 10)}...`
              )
            }
          }
        }
      }
    } catch (error) {
      // TLS/SSL errors might indicate weak configuration
      if (error instanceof TypeError && error.message.includes('SSL')) {
        vulnerabilities.push('TLS/SSL configuration issues detected')
      }
    }

    const executionTime = performance.now() - startTime

    return {
      testName: 'Cryptographic Weaknesses Test',
      category: 'CRYPTOGRAPHIC_FAILURES',
      status: vulnerabilities.length > 0 ? 'FAIL' : 'PASS',
      severity: vulnerabilities.length > 0 ? 'HIGH' : 'LOW',
      details:
        vulnerabilities.length > 0
          ? `Found ${vulnerabilities.length} cryptographic issues`
          : 'Cryptographic implementation appears secure',
      evidence: vulnerabilities,
      recommendations:
        vulnerabilities.length > 0
          ? [
              'Use strong TLS configuration (TLS 1.3 preferred)',
              'Implement proper session cookie security attributes',
              'Use cryptographically secure random number generation',
              'Implement proper key management practices',
              'Use strong encryption algorithms (AES-256, RSA-2048+)',
            ]
          : [],
      executionTime,
      timestamp: new Date(),
    }
  }

  /**
   * Information disclosure testing
   */
  private async scanInformationDisclosure(endpoint: string): Promise<SecurityTestResult> {
    const startTime = performance.now()
    const vulnerabilities: string[] = []

    try {
      // Test error handling for information disclosure
      const errorTests = [
        { name: 'Invalid parameter', url: `${endpoint}?invalid_param=true` },
        { name: 'Malformed JSON', url: endpoint, body: '{"invalid": json}' },
        { name: 'Large request', url: endpoint, body: 'x'.repeat(10000) },
      ]

      for (const test of errorTests) {
        try {
          const response = await fetch(test.url, {
            method: test.body ? 'POST' : 'GET',
            headers: test.body ? { 'Content-Type': 'application/json' } : {},
            body: test.body,
          })

          const responseText = await response.text()

          // Check for sensitive information disclosure
          const sensitivePatterns = [
            /\/[a-zA-Z]:[\\/][^<>\s"']+/g, // File paths
            /(?:password|secret|key)[\s]*[:=][\s]*[^\s<>"']+/gi, // Credentials
            /(?:database|db)[\s]*[:=][\s]*[^\s<>"']+/gi, // Database info
            /(?:exception|error)[\s]*[:=][\s]*[^\s<>"']+/gi, // Stack traces
            /\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b/g, // IP addresses
            /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g, // Email addresses
          ]

          for (const pattern of sensitivePatterns) {
            const matches = responseText.match(pattern)
            if (matches && matches.length > 0) {
              vulnerabilities.push(`${test.name}: Information disclosure - ${matches[0]}`)
            }
          }
        } catch (_error) {
          // Continue with other tests
        }
      }

      // Check HTTP headers for information disclosure
      const response = await fetch(endpoint)
      const serverHeader = response.headers.get('Server')
      if (serverHeader && (serverHeader.includes('/') || serverHeader.includes('.'))) {
        vulnerabilities.push(`Server header discloses version information: ${serverHeader}`)
      }

      const poweredByHeader = response.headers.get('X-Powered-By')
      if (poweredByHeader) {
        vulnerabilities.push(`X-Powered-By header discloses technology stack: ${poweredByHeader}`)
      }
    } catch (_error) {
      // Continue with assessment
    }

    const executionTime = performance.now() - startTime

    return {
      testName: 'Information Disclosure Test',
      category: 'SECURITY_MISCONFIGURATION',
      status: vulnerabilities.length > 0 ? 'FAIL' : 'PASS',
      severity: vulnerabilities.length > 0 ? 'MEDIUM' : 'LOW',
      details:
        vulnerabilities.length > 0
          ? `Found ${vulnerabilities.length} information disclosure issues`
          : 'No information disclosure vulnerabilities detected',
      evidence: vulnerabilities,
      recommendations:
        vulnerabilities.length > 0
          ? [
              'Implement generic error messages for all user-facing errors',
              'Remove server version headers and technology identifiers',
              'Implement proper exception handling to prevent stack trace disclosure',
              'Sanitize all error responses to remove sensitive information',
              'Use custom error pages for production environments',
            ]
          : [],
      executionTime,
      timestamp: new Date(),
    }
  }

  /**
   * Check if a token appears to be cryptographically weak
   */
  private isWeakToken(token: string): boolean {
    // Check for patterns that indicate weak randomness
    const weakPatterns = [
      /^[0-9]+$/, // Only numbers
      /^[a-z]+$/, // Only lowercase
      /^[A-Z]+$/, // Only uppercase
      /(.)\1{3,}/, // Repeated characters
      /012345|123456|abcdef|fedcba/, // Sequential patterns
    ]

    return weakPatterns.some(pattern => pattern.test(token)) || token.length < 16
  }

  /**
   * Generate comprehensive scan report
   */
  private generateScanReport(scanDuration: number): SecurityScanResult {
    const summary = {
      critical: this.results.filter(r => r.severity === 'CRITICAL').length,
      high: this.results.filter(r => r.severity === 'HIGH').length,
      medium: this.results.filter(r => r.severity === 'MEDIUM').length,
      low: this.results.filter(r => r.severity === 'LOW').length,
    }

    const totalVulnerabilities = summary.critical + summary.high + summary.medium
    const overallScore = Math.max(
      0,
      100 - (summary.critical * 25 + summary.high * 15 + summary.medium * 5 + summary.low * 1)
    )

    const recommendations = [...new Set(this.results.flatMap(r => r.recommendations || []))]

    return {
      overallScore,
      vulnerabilityCount: totalVulnerabilities,
      testResults: this.results,
      summary,
      recommendations,
      scanDuration,
      timestamp: new Date(),
    }
  }

  /**
   * Utility function to chunk array for concurrency control
   */
  private chunkArray<T>(array: T[], chunkSize: number): T[][] {
    const chunks: T[][] = []
    for (let i = 0; i < array.length; i += chunkSize) {
      chunks.push(array.slice(i, i + chunkSize))
    }
    return chunks
  }

  /**
   * Clear previous scan results
   */
  clearResults(): void {
    this.results = []
    this.attackSimulator.clearResults()
  }

  /**
   * Get current scan results
   */
  getResults(): SecurityTestResult[] {
    return [...this.results]
  }
}

// Export scanner instance and utilities
export const vulnerabilityScanner = new VulnerabilityScanner()
export const securityHeaders = SECURITY_HEADERS_CONFIG
export const owaspCategories = OWASP_TOP_10
